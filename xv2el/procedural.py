import numpy as np
import glob
import os
import astropy.constants as const
import datetime

# Define some global constants in SI units
GC = const.G.value
AU2M = const.au.value
GMSunSI = const.GM_sun.value
MSun = const.M_sun.value
JD2S = 86400

GMSunAUD = GMSunSI * JD2S**2 / AU2M**3

# Define some global variables
MSun_over_Mpl = {
    'Sun': 1.0,
    'Mercury': 6023600.0,
    'Venus': 408523.71,
    'Earth': 328900.56,
    'Mars': 3098708.,
    'Jupiter': 1047.3486,
    'Saturn': 3497.898,
    'Uranus': 22902.98,
    'Neptune': 19412.24,
    'Pluto': 1.35e8
}

def read_data(datadir):

    # Extract the names of all the input files contained in the data directory
    datafiles = glob.glob(os.path.join(datadir,"*-XV.csv"))

    # Initialize the two empty lists we plan to return
    planet_names = []
    xv_data_arr = []

    # Iterate over the names of the files in the list
    for filename in datafiles:
        planet_names.append(filename.split(os.path.sep)[2].split('-')[0]) # Extract the name of the planet from the name of the file
        xv_data_arr.append(np.genfromtxt(filename,delimiter=',',names=True)) # Load in the csv data as numpy array. np.genfromtxt will read the header in as well
    return xv_data_arr,planet_names

def convert_xv_to_el(xv_data_arr,planet_names):

    # First, I will extract the column names from the first element of the xv_data_arr list that was generated from np.genfromtxt
    input_column_names = xv_data_arr[0].dtype.names
    output_column_names = ['t','a','e','i','Omega','omega','varpi','f','M','lam']
    num_tvals = xv_data_arr[0].shape[0]
    num_elem_vals = len(output_column_names)

    # Initialize the empty list that will store the element data
    el_data_arr = []

    for i,planet in enumerate(planet_names):  # doing the iteration as an enumeration allows for us to loop over the planet name and xv_data_arr lists together, as they are paired.

        # Create the array that will store the new values
        el_data = np.empty([num_tvals,num_elem_vals])

        # Get the gravitational constant for the Sun+planet
        mu = GMSunAUD * (1.0 + 1.0/MSun_over_Mpl[planet])

        # Iterate over the time values in each array
        for j in range(num_tvals):
            # Compute the time value of this row, which is the first element of the tuple generated by np.genfromtxt
            t = xv_data_arr[i][j][0]

            # Now we need to extract just the position and velocity vectors from the tuple, so we can convert it to a list and hack off the time
            xvdata = list(xv_data_arr[i][j])[1:]
            elem = xv2el_one(mu,*xvdata) # Now I can pass the xv data list as an argument to xv2el_one using the *
            elem = list(elem)
            telem = [t]+elem
            el_data[j,:] = telem

        el_data_arr.append(el_data)

    return el_data_arr, output_column_names


def xv2el_one(mu,x,y,z,vx,vy,vz):
    """
    Converts from cartesian position and velocity values to orbital elements

    Parameters
    ----------
    mu : float
        Central body gravitational constant
    x : float
        Cartesian position along x-axis
    y : float
        Cartesian position along y-axis
    z : float
        Cartesian position along z-axis
    vx : float
        Cartesian velocity along x-axis
    vy : float
        Cartesian velocity along y-axis
    vz : float
        Cartesian velocity along z-axis

    Returns
    ----------
    a, e, i, Omega, omega, varpi, f, M, lam : tuple of floats

    a : float
        semimajor axis
    ecc : float
        eccentricity
    inc : float
        inclination (degrees)
    Omega : float
        longitude of ascending node (degrees)
    omega : float
        argument of periapsis (degrees)
    varpi : flaot
        longitude of periapsis (degrees)
    f : float
        true anomaly (degrees)
    M : float
        mean anomaly (degrees)
    lam : float
        mean longitude (degrees)

    """

    rvec = np.array([x,y,z])
    vvec = np.array([vx,vy,vz])
    rmag = np.linalg.norm(rvec)
    vmag2 = np.vdot(vvec,vvec)
    h = np.cross(rvec,vvec)
    hmag = np.linalg.norm(h)

    rdot = np.sign(np.vdot(rvec,vvec)) * np.sqrt(vmag2 - (hmag / rmag)**2)

    a = 1.0/(2.0 / rmag - vmag2/mu)
    ecc = np.sqrt(1 - hmag**2 / (mu * a))
    inc = np.arccos(h[2]/hmag)

    goodinc = np.abs(inc) > np.finfo(np.float64).tiny
    sO = np.where(goodinc,  np.sign(h[2]) * h[0] / (hmag * np.sin(inc)),0.0)
    cO = np.where(goodinc, -np.sign(h[2]) * h[1] / (hmag * np.sin(inc)),1.0)

    Omega = np.arctan2(sO, cO)

    sof = np.where(goodinc,rvec[2] / (rmag * np.sin(inc)), rvec[1]/rmag)
    cof = np.where(goodinc,(rvec[0] / rmag + np.sin(Omega) * sof * np.cos(inc)) / np.cos(Omega), rvec[0]/rmag)

    of = np.arctan2(sof,cof)

    goodecc = ecc > np.finfo(np.float64).tiny
    sf = np.where(goodecc,a * (1.0 - ecc**2)  * rdot / (hmag * ecc), 0.0)
    cf = np.where(goodecc,(1.0 / ecc) * (a * (1.0 - ecc**2) / rmag - 1.0), 1.0 )

    f = np.arctan2(sf, cf)

    omega = of - f

    omega = np.mod(omega, 2*np.pi)
    varpi = np.mod(Omega + omega,2*np.pi)

    # Compute eccentric anomaly & mean anomaly in order to get mean longitude
    E = np.where(ecc > np.finfo(np.float64).tiny, np.arccos(-(rmag - a) / (a * ecc)), 0)
    if np.sign(np.vdot(rvec, vvec)) < 0.0:
        E = 2 * np.pi - E

    M = E - ecc * np.sin(E)
    lam = np.mod(M + varpi,2*np.pi)

    return a, ecc, np.rad2deg(inc), np.rad2deg(Omega), np.rad2deg(omega), np.rad2deg(varpi), np.rad2deg(f), np.rad2deg(M), np.rad2deg(lam)


def write_data(datadir,el_data_arr,planet_names,output_column_names):
    # To use the column names as a header, we will need to convert the list of strings into a single comma-delimited string using join
    delimiter = ','
    header = delimiter.join(output_column_names)
    for i,planet in enumerate(planet_names):
        filename = os.path.join(datadir,f"{planet}-EL.csv")
        np.savetxt(filename,el_data_arr[i],delimiter=delimiter,header=header)
    return

if __name__ == '__main__':
    datadir = os.path.join(os.pardir,"data")
    xv_data_arr,planet_names = read_data(datadir)
    el_data_arr,output_column_names = convert_xv_to_el(xv_data_arr,planet_names)
    write_data(datadir,el_data_arr,planet_names,output_column_names)